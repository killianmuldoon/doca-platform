//go:build !ignore_autogenerated

/*
Copyright 2024 NVIDIA.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: nvidia/storage/plugins/v1/storage_plugin.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IdentityService_GetPluginInfo_FullMethodName = "/nvidia.storage.plugins.v1.IdentityService/GetPluginInfo"
	IdentityService_Probe_FullMethodName         = "/nvidia.storage.plugins.v1.IdentityService/Probe"
)

// IdentityServiceClient is the client API for IdentityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The Identity service provides APIs to identify the plugin and verify its health.
type IdentityServiceClient interface {
	// GetPluginInfo returns the name and version of the plugin.
	GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error)
	// Probe checks the health and readiness of the plugin.
	Probe(ctx context.Context, in *ProbeRequest, opts ...grpc.CallOption) (*ProbeResponse, error)
}

type identityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIdentityServiceClient(cc grpc.ClientConnInterface) IdentityServiceClient {
	return &identityServiceClient{cc}
}

func (c *identityServiceClient) GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, IdentityService_GetPluginInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityServiceClient) Probe(ctx context.Context, in *ProbeRequest, opts ...grpc.CallOption) (*ProbeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProbeResponse)
	err := c.cc.Invoke(ctx, IdentityService_Probe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IdentityServiceServer is the server API for IdentityService service.
// All implementations must embed UnimplementedIdentityServiceServer
// for forward compatibility.
//
// The Identity service provides APIs to identify the plugin and verify its health.
type IdentityServiceServer interface {
	// GetPluginInfo returns the name and version of the plugin.
	GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error)
	// Probe checks the health and readiness of the plugin.
	Probe(context.Context, *ProbeRequest) (*ProbeResponse, error)
	mustEmbedUnimplementedIdentityServiceServer()
}

// UnimplementedIdentityServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIdentityServiceServer struct{}

func (UnimplementedIdentityServiceServer) GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}
func (UnimplementedIdentityServiceServer) Probe(context.Context, *ProbeRequest) (*ProbeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Probe not implemented")
}
func (UnimplementedIdentityServiceServer) mustEmbedUnimplementedIdentityServiceServer() {}
func (UnimplementedIdentityServiceServer) testEmbeddedByValue()                         {}

// UnsafeIdentityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IdentityServiceServer will
// result in compilation errors.
type UnsafeIdentityServiceServer interface {
	mustEmbedUnimplementedIdentityServiceServer()
}

func RegisterIdentityServiceServer(s grpc.ServiceRegistrar, srv IdentityServiceServer) {
	// If the following call pancis, it indicates UnimplementedIdentityServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IdentityService_ServiceDesc, srv)
}

func _IdentityService_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_GetPluginInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).GetPluginInfo(ctx, req.(*GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityService_Probe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServiceServer).Probe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentityService_Probe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServiceServer).Probe(ctx, req.(*ProbeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IdentityService_ServiceDesc is the grpc.ServiceDesc for IdentityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IdentityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nvidia.storage.plugins.v1.IdentityService",
	HandlerType: (*IdentityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPluginInfo",
			Handler:    _IdentityService_GetPluginInfo_Handler,
		},
		{
			MethodName: "Probe",
			Handler:    _IdentityService_Probe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nvidia/storage/plugins/v1/storage_plugin.proto",
}

const (
	StoragePluginService_StoragePluginGetCapabilities_FullMethodName = "/nvidia.storage.plugins.v1.StoragePluginService/StoragePluginGetCapabilities"
	StoragePluginService_GetSNAPProvider_FullMethodName              = "/nvidia.storage.plugins.v1.StoragePluginService/GetSNAPProvider"
	StoragePluginService_CreateDevice_FullMethodName                 = "/nvidia.storage.plugins.v1.StoragePluginService/CreateDevice"
	StoragePluginService_DeleteDevice_FullMethodName                 = "/nvidia.storage.plugins.v1.StoragePluginService/DeleteDevice"
)

// StoragePluginServiceClient is the client API for StoragePluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The StoragePlugin service provides APIs to manage storage devices.
type StoragePluginServiceClient interface {
	// StoragePluginGetCapabilities returns the capabilities supported by the plugin.
	StoragePluginGetCapabilities(ctx context.Context, in *StoragePluginGetCapabilitiesRequest, opts ...grpc.CallOption) (*StoragePluginGetCapabilitiesResponse, error)
	// GetSNAPProvider retrieves the name of the SNAP provider used by the plugin.
	GetSNAPProvider(ctx context.Context, in *GetSNAPProviderRequest, opts ...grpc.CallOption) (*GetSNAPProviderResponse, error)
	// CreateDevice creates a new storage device and exposes it.
	CreateDevice(ctx context.Context, in *CreateDeviceRequest, opts ...grpc.CallOption) (*CreateDeviceResponse, error)
	// DeleteDevice removes a storage device.
	DeleteDevice(ctx context.Context, in *DeleteDeviceRequest, opts ...grpc.CallOption) (*DeleteDeviceResponse, error)
}

type storagePluginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStoragePluginServiceClient(cc grpc.ClientConnInterface) StoragePluginServiceClient {
	return &storagePluginServiceClient{cc}
}

func (c *storagePluginServiceClient) StoragePluginGetCapabilities(ctx context.Context, in *StoragePluginGetCapabilitiesRequest, opts ...grpc.CallOption) (*StoragePluginGetCapabilitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoragePluginGetCapabilitiesResponse)
	err := c.cc.Invoke(ctx, StoragePluginService_StoragePluginGetCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePluginServiceClient) GetSNAPProvider(ctx context.Context, in *GetSNAPProviderRequest, opts ...grpc.CallOption) (*GetSNAPProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSNAPProviderResponse)
	err := c.cc.Invoke(ctx, StoragePluginService_GetSNAPProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePluginServiceClient) CreateDevice(ctx context.Context, in *CreateDeviceRequest, opts ...grpc.CallOption) (*CreateDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDeviceResponse)
	err := c.cc.Invoke(ctx, StoragePluginService_CreateDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePluginServiceClient) DeleteDevice(ctx context.Context, in *DeleteDeviceRequest, opts ...grpc.CallOption) (*DeleteDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDeviceResponse)
	err := c.cc.Invoke(ctx, StoragePluginService_DeleteDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoragePluginServiceServer is the server API for StoragePluginService service.
// All implementations must embed UnimplementedStoragePluginServiceServer
// for forward compatibility.
//
// The StoragePlugin service provides APIs to manage storage devices.
type StoragePluginServiceServer interface {
	// StoragePluginGetCapabilities returns the capabilities supported by the plugin.
	StoragePluginGetCapabilities(context.Context, *StoragePluginGetCapabilitiesRequest) (*StoragePluginGetCapabilitiesResponse, error)
	// GetSNAPProvider retrieves the name of the SNAP provider used by the plugin.
	GetSNAPProvider(context.Context, *GetSNAPProviderRequest) (*GetSNAPProviderResponse, error)
	// CreateDevice creates a new storage device and exposes it.
	CreateDevice(context.Context, *CreateDeviceRequest) (*CreateDeviceResponse, error)
	// DeleteDevice removes a storage device.
	DeleteDevice(context.Context, *DeleteDeviceRequest) (*DeleteDeviceResponse, error)
	mustEmbedUnimplementedStoragePluginServiceServer()
}

// UnimplementedStoragePluginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStoragePluginServiceServer struct{}

func (UnimplementedStoragePluginServiceServer) StoragePluginGetCapabilities(context.Context, *StoragePluginGetCapabilitiesRequest) (*StoragePluginGetCapabilitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoragePluginGetCapabilities not implemented")
}
func (UnimplementedStoragePluginServiceServer) GetSNAPProvider(context.Context, *GetSNAPProviderRequest) (*GetSNAPProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSNAPProvider not implemented")
}
func (UnimplementedStoragePluginServiceServer) CreateDevice(context.Context, *CreateDeviceRequest) (*CreateDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDevice not implemented")
}
func (UnimplementedStoragePluginServiceServer) DeleteDevice(context.Context, *DeleteDeviceRequest) (*DeleteDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDevice not implemented")
}
func (UnimplementedStoragePluginServiceServer) mustEmbedUnimplementedStoragePluginServiceServer() {}
func (UnimplementedStoragePluginServiceServer) testEmbeddedByValue()                              {}

// UnsafeStoragePluginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StoragePluginServiceServer will
// result in compilation errors.
type UnsafeStoragePluginServiceServer interface {
	mustEmbedUnimplementedStoragePluginServiceServer()
}

func RegisterStoragePluginServiceServer(s grpc.ServiceRegistrar, srv StoragePluginServiceServer) {
	// If the following call pancis, it indicates UnimplementedStoragePluginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StoragePluginService_ServiceDesc, srv)
}

func _StoragePluginService_StoragePluginGetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoragePluginGetCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePluginServiceServer).StoragePluginGetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePluginService_StoragePluginGetCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePluginServiceServer).StoragePluginGetCapabilities(ctx, req.(*StoragePluginGetCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePluginService_GetSNAPProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSNAPProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePluginServiceServer).GetSNAPProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePluginService_GetSNAPProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePluginServiceServer).GetSNAPProvider(ctx, req.(*GetSNAPProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePluginService_CreateDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePluginServiceServer).CreateDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePluginService_CreateDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePluginServiceServer).CreateDevice(ctx, req.(*CreateDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePluginService_DeleteDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePluginServiceServer).DeleteDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePluginService_DeleteDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePluginServiceServer).DeleteDevice(ctx, req.(*DeleteDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StoragePluginService_ServiceDesc is the grpc.ServiceDesc for StoragePluginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StoragePluginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nvidia.storage.plugins.v1.StoragePluginService",
	HandlerType: (*StoragePluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoragePluginGetCapabilities",
			Handler:    _StoragePluginService_StoragePluginGetCapabilities_Handler,
		},
		{
			MethodName: "GetSNAPProvider",
			Handler:    _StoragePluginService_GetSNAPProvider_Handler,
		},
		{
			MethodName: "CreateDevice",
			Handler:    _StoragePluginService_CreateDevice_Handler,
		},
		{
			MethodName: "DeleteDevice",
			Handler:    _StoragePluginService_DeleteDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nvidia/storage/plugins/v1/storage_plugin.proto",
}
