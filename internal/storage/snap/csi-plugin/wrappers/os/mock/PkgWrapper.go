// /*
// Copyright 2024 NVIDIA.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */

// Code generated by MockGen. DO NOT EDIT.
// Source: os.go
//
// Generated by this command:
//
//	mockgen -copyright_file ../../../../../../hack/boilerplate.go.txt -destination mock/PkgWrapper.go -source os.go
//

// Package mock_os is a generated GoMock package.
package mock_os

import (
	os "os"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockPkgWrapper is a mock of PkgWrapper interface.
type MockPkgWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockPkgWrapperMockRecorder
	isgomock struct{}
}

// MockPkgWrapperMockRecorder is the mock recorder for MockPkgWrapper.
type MockPkgWrapperMockRecorder struct {
	mock *MockPkgWrapper
}

// NewMockPkgWrapper creates a new mock instance.
func NewMockPkgWrapper(ctrl *gomock.Controller) *MockPkgWrapper {
	mock := &MockPkgWrapper{ctrl: ctrl}
	mock.recorder = &MockPkgWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPkgWrapper) EXPECT() *MockPkgWrapperMockRecorder {
	return m.recorder
}

// MkdirAll mocks base method.
func (m *MockPkgWrapper) MkdirAll(path string, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockPkgWrapperMockRecorder) MkdirAll(path, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockPkgWrapper)(nil).MkdirAll), path, perm)
}

// OpenFile mocks base method.
func (m *MockPkgWrapper) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", name, flag, perm)
	ret0, _ := ret[0].(*os.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockPkgWrapperMockRecorder) OpenFile(name, flag, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockPkgWrapper)(nil).OpenFile), name, flag, perm)
}

// ReadDir mocks base method.
func (m *MockPkgWrapper) ReadDir(name string) ([]os.DirEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDir", name)
	ret0, _ := ret[0].([]os.DirEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadDir indicates an expected call of ReadDir.
func (mr *MockPkgWrapperMockRecorder) ReadDir(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDir", reflect.TypeOf((*MockPkgWrapper)(nil).ReadDir), name)
}

// ReadFile mocks base method.
func (m *MockPkgWrapper) ReadFile(name string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", name)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockPkgWrapperMockRecorder) ReadFile(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockPkgWrapper)(nil).ReadFile), name)
}

// Readlink mocks base method.
func (m *MockPkgWrapper) Readlink(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockPkgWrapperMockRecorder) Readlink(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockPkgWrapper)(nil).Readlink), name)
}

// RemoveAll mocks base method.
func (m *MockPkgWrapper) RemoveAll(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAll", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAll indicates an expected call of RemoveAll.
func (mr *MockPkgWrapperMockRecorder) RemoveAll(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAll", reflect.TypeOf((*MockPkgWrapper)(nil).RemoveAll), path)
}

// Stat mocks base method.
func (m *MockPkgWrapper) Stat(name string) (os.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", name)
	ret0, _ := ret[0].(os.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockPkgWrapperMockRecorder) Stat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockPkgWrapper)(nil).Stat), name)
}

// WriteFile mocks base method.
func (m *MockPkgWrapper) WriteFile(name string, data []byte, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", name, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockPkgWrapperMockRecorder) WriteFile(name, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockPkgWrapper)(nil).WriteFile), name, data, perm)
}
